## 实时系统

**实时系统是指在确定的时间内完成规定功能，并能对外部异步事件作出正确响应的计算机系统。**

分类：
硬实时系统、FIRM（严格）实时系统、软实时系统
在出现结果迟到的问题上，只有软实时系统影响最小

衡量实时性的指标
- 响应时间 (Response Time)
- 生存时间（Survival Time)
- 吞吐量(Throughput)
## 嵌入式实时系统

开发原则：尽量确保系统的正常运行不依赖于运行逻辑结果
系统对于各种外部输入在预定时间内能得到可预测的结果

RTOS
- 在不同的系统负载下,行为可以预测
- 支持基于优先级的调度
- MEMORY模型对于RTOS的性能十分重要
- 通常都需要一个时钟来处理任务的同步

## 嵌入式实时系统的几大特点

实时性
反应时间要快，按要求的间隔输出正确时间信号给实时的控制设备

快速启动
快速启动，并有出错处理和自动复位功能

多任务并发性
利用适当的策略控制多任务的执行，提高资源的利用效率

运行空间
嵌入式实时软件是应用程序和操作系统两种软件的一体化程序

异步事件
有处理异步事件的能力

开发方式
嵌入式实时软件的开发需要独立的开发平台和交叉开发环境

> uClinux：嵌入式Linux，结构复杂，移植难度大，实时性没那么好


## 线程控制块

意思是表示一个管理线程的一个结构体

![](https://gitee.com/alicization/2024-rsoc-rtthread/raw/master/imgs/202407270634387.png)


>线程控制块由结构体 struct rt_thread 定义并形成线程内核对象，再链接到内核对象容器中进行管理。

![](https://gitee.com/alicization/2024-rsoc-rtthread/raw/master/imgs/202407270634388.png)
线程继承自rt_object

## 线程属性-线程栈
- RT-Thread的线程具有独立的栈空间，当进行线程切换时，会将当前线程的上下文存在栈中，当线程要恢复运行时，再从栈中读取上下文信息，进行恢复。
- 线程栈还用来存放函数中的局部变量：函数中的局部变量从线程栈空间中申请；初始时局部变量会从寄存器中分配（ARM架构），当这个函数再调用另一个函数时，这些局部变量将放入栈中。
- 线程栈的增长方向与芯片构架密切相关的，RT-Thread3.1.0以前的版本，均只支持栈由高地址向低地址的增长方式，对于ARM Cortex-M架构，线程栈可构造如右图所示。
- 
 ![](https://gitee.com/alicization/2024-rsoc-rtthread/raw/master/imgs/202407270634389.png)

## RT-Thread启动流程

![Pasted image 20240723191322](https://gitee.com/alicization/2024-rsoc-rtthread/raw/master/imgs/202407270634400.png)
## RT_Thread状态



![](https://gitee.com/alicization/2024-rsoc-rtthread/raw/master/imgs/202407270634390.png)


## RT-Thread启动流程分析

首先看下rtthread的启动文件startup_stm32f407xx.s

根据上图的描述，我们可以尝试在汇编文件里找到enrty(),并打下断点，编译运行，单步进入

这样就能发现rt-thread最开始启动函数原来藏这里了

![](https://gitee.com/alicization/2024-rsoc-rtthread/raw/master/imgs/202407270634391.png)

这时在进入这个函数的定义就可以发现上图所有的函数都在里面了

![](https://gitee.com/alicization/2024-rsoc-rtthread/raw/master/imgs/202407270634393.png)

由于解释起来篇幅比较大所以感兴趣的读者可以自行跳转进去看一看
这里主要记录下main的线程是怎么运行的

## Main线程调度

注意rt_application_init这个函数，查看下定义可以看到

![](https://gitee.com/alicization/2024-rsoc-rtthread/raw/master/imgs/202407270634394.png)

init初始化创建了一个线程，然后startup启动了这个线程，看下这个创建线程的定义

![](https://gitee.com/alicization/2024-rsoc-rtthread/raw/master/imgs/202407270634395.png)

首先是申请了一块上面提到的线程控制块中的rt_thread结构体内存
然后把结构体的内容通过_thread_init进行初始化，并将线程状态设为初始状态,以及线程其他内容的初始化
初始化的过程中还包括了线程栈的初始化,其中pc则是main线程的回调函数指针

![](https://gitee.com/alicization/2024-rsoc-rtthread/raw/master/imgs/202407270634396.png)

然后是startup,这个函数内部主要做的是把线程从初始化转为就绪状态

接下来回到rtthread_startup下的rt_thread_idle_init()初始化，这里主要跟平时使用的delay函数有关

可以看到跟main一样，也是创建了一个tidle线程，然后放到就绪态

继续往下，则是系统调度器的初始化

![](https://gitee.com/alicization/2024-rsoc-rtthread/raw/master/imgs/202407270634397.png)

这里主要就是找到高优先级的线程然后把线程就转为运行态
## Delay函数中的线程调度

当使用rt_thread_mdelay后,就会来到_thread_sleep

![](https://gitee.com/alicization/2024-rsoc-rtthread/raw/master/imgs/202407270634398.png)

rt_thread_suspend_with_flag获取线程状态然后将当前的线程挂起，接下来设置开启定时器，然后调度切换其他线程

## RT-Thread线程实例

接下来尝试开两个线程打印输出count

```c
#define THREAD_PRIORITY         25

#define THREAD_STACK_SIZE       512

#define THREAD_TIMESLICE        5

struct tid_param

{

    int id;

    int ms;

};

static struct rt_thread *tid1;

static struct rt_thread *tid2;

static void thread_entry(void *param)

{

    rt_uint32_t count=0;

    struct tid_param *tid_p =(struct tid_param *)param;

    for(count=0;count<10;count++)

    {

        rt_kprintf("thread%d %d\n",tid_p->id,count);

        rt_thread_mdelay(tid_p->ms);

    }

    rt_kprintf("thread%d exit\n",tid_p->id);

}

static int thread_sample(void)

{

    struct tid_param *tid1_param=(struct tid_param*)rt_malloc(sizeof(struct tid_param));

    tid1_param->id=1;

    tid1_param->ms=1000;

    tid1=rt_thread_create("tid1",thread_entry,(void*)tid1_param,THREAD_STACK_SIZE,THREAD_PRIORITY,THREAD_TIMESLICE);

    if(tid1!=RT_NULL)

    {

        rt_thread_startup(tid1);

    }

    struct tid_param *tid2_param=(struct tid_param*)rt_malloc(sizeof(struct tid_param));

    tid2_param->id=2;

    tid2_param->ms=1000;

    tid2=rt_thread_create("tid2",thread_entry,(void*)tid2_param,THREAD_STACK_SIZE,THREAD_PRIORITY,THREAD_TIMESLICE);

    if(tid2!=RT_NULL)

    {

        rt_thread_startup(tid2);

    }

  

}
MSH_CMD_EXPORT(thread_sample,thread_sample);

int main(void)

{

    return 0;

}
```

编译运行看下效果
![](https://gitee.com/alicization/2024-rsoc-rtthread/raw/master/imgs/202407270634399.png)

可以看到两个线程交替输出count计数

